local AimlockModule = {}

function AimlockModule.Init(player, char, camera)
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	local Workspace = game:GetService("Workspace")
	local gui = player:WaitForChild("PlayerGui")
	local cursorDot1 = gui:WaitForChild("MobileMouselock"):WaitForChild("Cursor")
	
    if not char then
        player.CharacterAdded:Wait()
        char = player.Character
    end
    
	local humanoid = char:WaitForChild("Humanoid")
	local AimlockPlayerEnabled = false
	local AimlockNpcEnabled = false
	local currentTarget = nil
	local currentTool = nil
	local vActive, zActive = false, false
	local tiltEnabled = false
	local rightTouches = {}
	local tiltConn, preTiltCFrame, healthConn = nil, nil, nil
	local highlights, bossHighlights = {}, {}
	local connections = {}
	local currentEnemyTarget = nil
	local currentBossTarget = nil
	local currentHighlight = nil

-- =========================
-- Team Check
-- =========================
local function isAllyWithMe(targetPlayer)
	local myGui = player:FindFirstChild("PlayerGui")
	if not myGui then return false end

	local scrolling = myGui:FindFirstChild("Main")
		and myGui.Main:FindFirstChild("Allies")
		and myGui.Main.Allies:FindFirstChild("Container")
		and myGui.Main.Allies.Container:FindFirstChild("Allies")
		and myGui.Main.Allies.Container.Allies:FindFirstChild("ScrollingFrame")

	if scrolling then
		for _, frame in pairs(scrolling:GetDescendants()) do
			if frame:IsA("ImageButton") and frame.Name == targetPlayer.Name then
				return true
			end
		end
	end

	return false
end

local function isEnemy(targetPlayer)
	if not targetPlayer or targetPlayer == player then
		return false
	end

	local myTeam = player.Team
	local targetTeam = targetPlayer.Team

	if myTeam and targetTeam then
		if myTeam.Name == "Pirates" and targetTeam.Name == "Marines" then
			return true
		elseif myTeam.Name == "Marines" and targetTeam.Name == "Pirates" then
			return true
		end

		if myTeam.Name == "Pirates" and targetTeam.Name == "Pirates" then
			if isAllyWithMe(targetPlayer) then
				return false -- ally, not enemy
			end
			return true
		end

		if myTeam.Name == "Marines" and targetTeam.Name == "Marines" then
			return false
		end
	end

	return true
end

-- =========================
-- Enemies Finder
-- =========================
local function getNearestEnemy(maxDistance)
	local hrp = char:WaitForChild("HumanoidRootPart")
	local nearest, shortest = nil, maxDistance or 100

	for _, p in pairs(Players:GetPlayers()) do
		if p ~= player and isEnemy(p) and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
			local humanoid = p.Character:FindFirstChildOfClass("Humanoid")
			if humanoid and humanoid.Health > 0 then
				local enemyHRP = p.Character.HumanoidRootPart
				local dist = (enemyHRP.Position - hrp.Position).Magnitude
				if dist < shortest then
					shortest = dist
					nearest = enemyHRP
				end
			end
		end
	end

	return nearest
end

local function getNearestBoss(maxDistance)
	local hrp = char:WaitForChild("HumanoidRootPart")
	local nearest, shortest = nil, maxDistance or 500
	local bossFolder = Workspace:FindFirstChild("Enemies")
	if bossFolder then
		for _, boss in pairs(bossFolder:GetChildren()) do
			local humanoid = boss:FindFirstChildOfClass("Humanoid")
			if boss:FindFirstChild("HumanoidRootPart") and humanoid and humanoid.Health > 0 then
				local bossHRP = boss.HumanoidRootPart
				local dist = (bossHRP.Position - hrp.Position).Magnitude
				if dist < shortest then
					shortest = dist
					nearest = bossHRP
				end
			end
		end
	end
	return nearest
end

-- =========================
-- Main Aimlock & Highlight Loop
-- =========================
local renderConnMain = RunService.RenderStepped:Connect(function()
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    for _, p in pairs(Players:GetPlayers()) do
        if p ~= player and isEnemy(p) and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
            local humanoid = p.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                if not highlights[p] then
                    local highlight = Instance.new("Highlight")
                    highlight.Adornee = p.Character
                    highlight.FillColor = Color3.fromRGB(240, 248, 255)
                    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
                    highlight.Parent = p.Character
                    highlights[p] = highlight
                end
            else
                if highlights[p] then
                    highlights[p]:Destroy()
                    highlights[p] = nil
                end
            end
        else
            if highlights[p] then
                highlights[p]:Destroy()
                highlights[p] = nil
            end
        end
    end
    
    if AimlockNpcEnabled then
        local bossFolder = Workspace:FindFirstChild("Enemies")
        if bossFolder then
            for _, boss in pairs(bossFolder:GetChildren()) do
                local humanoid = boss:FindFirstChildOfClass("Humanoid")
                if boss:FindFirstChild("HumanoidRootPart") and humanoid and humanoid.Health > 0 then
                    if not bossHighlights[boss] then
                        local highlight = Instance.new("Highlight")
                        highlight.Adornee = boss
                        highlight.FillColor = Color3.fromRGB(0, 0, 255)
                        highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
                        highlight.Parent = boss
                        bossHighlights[boss] = highlight
                    end
                end
            end
        end
    else
        for b, h in pairs(bossHighlights) do
            if h then h:Destroy() end
        end
        bossHighlights = {}
    end
    
    if not tiltEnabled then
        if AimlockPlayerEnabled then
            if not currentEnemyTarget or not currentEnemyTarget.Parent 
                or not currentEnemyTarget.Parent:FindFirstChildOfClass("Humanoid") 
                or currentEnemyTarget.Parent:FindFirstChildOfClass("Humanoid").Health <= 0 then
                currentEnemyTarget = getNearestEnemy(500)
            end

            if currentEnemyTarget then
                local dist = (currentEnemyTarget.Position - camera.CFrame.Position).Magnitude
                local tiltFactor = math.clamp(dist / 40, 0, 0.08)
                local lookVector = (currentEnemyTarget.Position - camera.CFrame.Position).Unit
                local tiltedLook = Vector3.new(lookVector.X, lookVector.Y - tiltFactor, lookVector.Z).Unit
                camera.CFrame = CFrame.new(camera.CFrame.Position, camera.CFrame.Position + tiltedLook)
            end
        end

        if AimlockNpcEnabled then
            if not currentBossTarget or not currentBossTarget.Parent 
                or not currentBossTarget.Parent:FindFirstChildOfClass("Humanoid") 
                or currentBossTarget.Parent:FindFirstChildOfClass("Humanoid").Health <= 0 then
                currentBossTarget = getNearestBoss(500)
            end

            if currentBossTarget then
                local dist = (currentBossTarget.Position - camera.CFrame.Position).Magnitude
                local tiltFactor = math.clamp(dist / 40, 0, 0.08)
                local lookVector = (currentBossTarget.Position - camera.CFrame.Position).Unit
                local tiltedLook = Vector3.new(lookVector.X, lookVector.Y - tiltFactor, lookVector.Z).Unit
                camera.CFrame = CFrame.new(camera.CFrame.Position, camera.CFrame.Position + tiltedLook)
            end
        end
    end
end)
table.insert(connections, renderConnMain)

-- =========================
-- Tilt Camera Function
-- =========================
local function disconnectTiltConn()
	if tiltConn then
		tiltConn:Disconnect()
		tiltConn = nil
	end
end

local function stopTiltSmooth()
	disconnectTiltConn()
	if not preTiltCFrame then return end

	local startCF = camera.CFrame
	local endCF = preTiltCFrame
	preTiltCFrame = nil

	local a = 0
	local restoreConn
	restoreConn = RunService.RenderStepped:Connect(function(dt)
		a = math.min(a + dt * 5, 1)
		camera.CFrame = startCF:Lerp(endCF, a)
		if a >= 1 then
			restoreConn:Disconnect()
		end
	end)
end

local function startTilt()
	disconnectTiltConn()

	preTiltCFrame = preTiltCFrame or camera.CFrame
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end
	local humanoid = char:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end

	local startCF = camera.CFrame
	local camPos = startCF.Position

	local tiltOffset
	if humanoid.FloorMaterial ~= Enum.Material.Air then
		tiltOffset = Vector3.new(0, 10, 0)
	else
		tiltOffset = Vector3.new(0, 30, 0)
	end

	local downLook = hrp.Position - tiltOffset
	local targetCF = CFrame.new(camPos, downLook)

	local alpha = 0
	tiltConn = RunService.RenderStepped:Connect(function(dt)
		if not (tiltEnabled and next(rightTouches) and hrp.Parent) then
			stopTiltSmooth()
			return
		end

		if alpha < 1 then
			alpha = math.min(alpha + dt * 2, 1)
			camera.CFrame = startCF:Lerp(targetCF, alpha)
		else
			camera.CFrame = targetCF
		end
	end)
end

-- =========================
-- Touch tracking
-- =========================
UserInputService.TouchStarted:Connect(function(touch)
	if touch.Position.X > camera.ViewportSize.X / 2 then
		rightTouches[touch] = true
		if tiltEnabled then
			startTilt()
		end
	end
end)

UserInputService.TouchEnded:Connect(function(touch)
	if rightTouches[touch] then
		rightTouches[touch] = nil
		if not next(rightTouches) then
			stopTiltSmooth()
			tiltEnabled = false
			vActive = false
			zActive = false
		end
	end
end)

-- =========================
-- Target tracking with Dot cursor & Health detection (Players + NPCs)
-- =========================
local function getAllParts(model)
    local parts = {}
    for _, descendant in pairs(model:GetDescendants()) do
        if descendant:IsA("BasePart") then
            table.insert(parts, descendant)
        end
    end
    return parts
end

local function clearHighlight()
    if currentHighlight then
        currentHighlight:Destroy()
        currentHighlight = nil
    end
end

local function setHighlight(targetModel, color)
    clearHighlight()
    if targetModel then
        local highlight = Instance.new("Highlight")
        highlight.FillColor = color or Color3.fromRGB(255, 255, 0) -- default yellow
        highlight.OutlineColor = color or Color3.fromRGB(255, 255, 0)
        highlight.FillTransparency = 0.5
        highlight.OutlineTransparency = 0
        highlight.Adornee = targetModel.PrimaryPart or targetModel:FindFirstChild("HumanoidRootPart") or targetModel
        highlight.Parent = targetModel
        currentHighlight = highlight
    end
end

local function setTarget(targetModel)
    if targetModel ~= currentTarget then
        if healthConn then
            healthConn:Disconnect()
            healthConn = nil
        end

        currentTarget = targetModel
        clearHighlight()

        if targetModel then
            setHighlight(targetModel, Color3.fromRGB(255, 255, 0))

            local humanoid = targetModel:FindFirstChildOfClass("Humanoid")
            if humanoid then
                local lastHealth = humanoid.Health
                healthConn = humanoid.HealthChanged:Connect(function(newHealth)
                    if currentTool then
                        local toolName = currentTool.Name
                        if (toolName == "Dough-Dough" and vActive) or (toolName == "Shark Anchor" and zActive) then
                            if newHealth < lastHealth then
                                tiltEnabled = true
                                if next(rightTouches) then
                                    startTilt()
                                end
                            end
                        end
                    end
                    lastHealth = newHealth
                end)
            end
        end
    end
end

local renderConnDot = RunService.RenderStepped:Connect(function()
    if not cursorDot1 or not cursorDot1.Parent then
        print("Cursor dot not ready")
        return
    end


    local dotPos = cursorDot1.AbsolutePosition + cursorDot1.AbsoluteSize / 2
    local ray = camera:ScreenPointToRay(dotPos.X, dotPos.Y)

    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Whitelist
    rayParams.FilterDescendantsInstances = {}
    if #rayParams.FilterDescendantsInstances == 0 then
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        rayParams.FilterDescendantsInstances = {char} -- avoid hitting yourself
    end

    if AimlockNpcEnabled then
        local enemiesFolder = Workspace:FindFirstChild("Enemies")
        if enemiesFolder then
            for _, npc in pairs(enemiesFolder:GetChildren()) do
                if npc:FindFirstChildOfClass("Humanoid") then
                    for _, part in pairs(getAllParts(npc)) do
                        table.insert(rayParams.FilterDescendantsInstances, part)
                    end
                end
            end
        end
    end

    if AimlockPlayerEnabled then
        for _, p in pairs(Players:GetPlayers()) do
            if p ~= player and isEnemy(p) and p.Character then
                for _, part in pairs(getAllParts(p.Character)) do
                    table.insert(rayParams.FilterDescendantsInstances, part)
                end
            end
        end
    end

    local raycastResult = Workspace:Raycast(ray.Origin, ray.Direction * 1000, rayParams)
    if raycastResult and raycastResult.Instance then
        local model = raycastResult.Instance:FindFirstAncestorOfClass("Model")
        if model and model:FindFirstChildOfClass("Humanoid") then
            setTarget(model)
            print("Dot cursor position:", dotPos)
            print("Hit instance:", raycastResult.Instance:GetFullName())
            return
        end
    end
    
    print("Ray missed all targets")
    setTarget(nil)
end)
table.insert(connections, renderConnDot)

-- =========================
-- Tool equip / unequip 
-- =========================
local function hookTool(tool)
	currentTool = tool
	tool.AncestryChanged:Connect(function(_, parent)
		if not parent then
			currentTool = nil
			vActive = false
			zActive = false
			tiltEnabled = false
			stopTiltSmooth()
		end
	end)
end

char.ChildAdded:Connect(function(child)
	if child:IsA("Tool") then
		hookTool(child)
	end
end)

char.ChildRemoved:Connect(function(child)
	if child == currentTool then
		currentTool = nil
		vActive = false
		zActive = false
		tiltEnabled = false
		stopTiltSmooth()
	end
end)

-- =========================
-- V Skill Detection
-- =========================
local old
old = hookmetamethod(game, "__namecall", function(self, ...)
	local method = getnamecallmethod()
	local args = {...}

	if (method == "InvokeServer" or method == "FireServer") then
		local a1 = args[1]

		if typeof(a1) == "string" and a1:upper() == "V" then
			if currentTool and currentTool.Name == "Dough-Dough" then
				vActive = true
				local stamp = os.clock()
				task.delay(2, function()
					if not tiltEnabled and os.clock() - stamp >= 2 then
						vActive = false
					end
				end)
			end
		end

		if typeof(a1) == "string" and a1:upper() == "Z" then
			if currentTool and currentTool.Name == "Shark Anchor" then
				zActive = true
				local stamp = os.clock()
				task.delay(2, function()
					if not tiltEnabled and os.clock() - stamp >= 2 then
						zActive = false
					end
				end)
			end
		end

		if currentTool and currentTool.Name == "Shark Anchor" and self.Name == "EquipEvent" then
			local arg1 = args[1]
			if arg1 == false then
				currentTool = nil
				zActive = false
				tiltEnabled = false
				stopTiltSmooth()
			end
		end
	end
	return old(self, ...)
end)

-- =========================
-- Cleanup 
-- =========================
local oldHook = old
local function cleanup()
    for _, conn in pairs(connections) do
        if conn.Connected then conn:Disconnect() end
    end
    connections = {}

    if healthConn then
        healthConn:Disconnect()
        healthConn = nil
    end

    disconnectTiltConn()
    currentTool = nil
    rightTouches = {}
    vActive = false
    zActive = false
    tiltEnabled = false
    preTiltCFrame = nil

    if oldHook then
        hookmetamethod(game, "__namecall", oldHook)
        oldHook = nil
    end

    for _, h in pairs(highlights) do
        h:Destroy()
    end
    highlights = {}
    for _, h in pairs(bossHighlights) do
        h:Destroy()
    end
    bossHighlights = {}
end

-- =========================
-- lifecycle
-- =========================
player.CharacterAdded:Connect(function(c)
	cleanup()
	char = c
	humanoid = char:WaitForChild("Humanoid")
	vActive = false
	zActive = false
	tiltEnabled = false
	rightTouches = {}
	stopTiltSmooth()
end)

player.CharacterRemoving:Connect(function()
	vActive = false
	zActive = false
	tiltEnabled = false
	rightTouches = {}
	disconnectTiltConn()
	currentTool = nil
end)

	-- =========================
	-- RETURN TABLE FOR MAIN SCRIPT USAGE
	-- =========================
	return {
		toggleAimlock = function(state)
			AimlockPlayerEnabled = state
			if not state then
			    currentEnemyTarget = nil
			end
		end,
		toggleBossAimlock = function(state)
			AimlockNpcEnabled = state
			if not state then
			    currentBossTarget = nil
			end
		end,
		cleanup = cleanup
	}
end

return AimlockModule
