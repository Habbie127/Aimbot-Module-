local AimlockModule = {}

function AimlockModule.Init(player, char, camera)
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	local Workspace = game:GetService("Workspace")
	
    if not char then
        player.CharacterAdded:Wait()
        char = player.Character
    end
    
	-- VARIABLES
	local humanoid = char:WaitForChild("Humanoid")
	local aimlockEnabled = false
	local bossAimlockEnabled = false
	local FOV = 75
	local OFFSET = Vector3.new(0, 2.5, 0)
	local currentTarget = nil
	local currentTool = nil
	local vActive, zActive = false, false
	local tiltEnabled = false
	local rightTouches = {}
	local tiltConn, preTiltCFrame, healthConn = nil, nil, nil
	local highlights, bossHighlights = {}, {}
	local connections = {}

-- =========================
-- Ipad View
-- =========================
local function applySettings()
	if not player.Character then return end
	local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		humanoid.CameraOffset = OFFSET
	end
	camera.FieldOfView = FOV
end

player.CharacterAdded:Connect(function(char)
	char:WaitForChild("Humanoid")
	applySettings()
end)

if player.Character then
	applySettings()
end

-- =========================
-- Team Check
-- =========================
local function isAllyWithMe(targetPlayer)
	local myGui = player:FindFirstChild("PlayerGui")
	if not myGui then return false end

	local scrolling = myGui:FindFirstChild("Main")
		and myGui.Main:FindFirstChild("Allies")
		and myGui.Main.Allies:FindFirstChild("Container")
		and myGui.Main.Allies.Container:FindFirstChild("Allies")
		and myGui.Main.Allies.Container.Allies:FindFirstChild("ScrollingFrame")

	if scrolling then
		for _, frame in pairs(scrolling:GetDescendants()) do
			if frame:IsA("ImageButton") and frame.Name == targetPlayer.Name then
				return true
			end
		end
	end

	return false
end

local function isEnemy(targetPlayer)
	if not targetPlayer or targetPlayer == player then
		return false
	end

	local myTeam = player.Team
	local targetTeam = targetPlayer.Team

	if myTeam and targetTeam then
		if myTeam.Name == "Pirates" and targetTeam.Name == "Marines" then
			return true
		elseif myTeam.Name == "Marines" and targetTeam.Name == "Pirates" then
			return true
		end

		if myTeam.Name == "Pirates" and targetTeam.Name == "Pirates" then
			if isAllyWithMe(targetPlayer) then
				return false -- ally, not enemy
			end
			return true
		end

		if myTeam.Name == "Marines" and targetTeam.Name == "Marines" then
			return false
		end
	end

	return true
end

-- =========================
-- Enemies Finder
-- =========================
local function getNearestEnemy(maxDistance)
	local hrp = char:WaitForChild("HumanoidRootPart")
	local nearest, shortest = nil, maxDistance or 100

	for _, p in pairs(Players:GetPlayers()) do
		if p ~= player and isEnemy(p) and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
			local humanoid = p.Character:FindFirstChildOfClass("Humanoid")
			if humanoid and humanoid.Health > 0 then
				local enemyHRP = p.Character.HumanoidRootPart
				local dist = (enemyHRP.Position - hrp.Position).Magnitude
				if dist < shortest then
					shortest = dist
					nearest = enemyHRP
				end
			end
		end
	end

	return nearest
end

local function getNearestBoss(maxDistance)
	local hrp = char:WaitForChild("HumanoidRootPart")
	local nearest, shortest = nil, maxDistance or 500
	local bossFolder = Workspace:FindFirstChild("Enemies")
	if bossFolder then
		for _, boss in pairs(bossFolder:GetChildren()) do
			if boss:FindFirstChild("HumanoidRootPart") then
				local bossHRP = boss.HumanoidRootPart
				local dist = (bossHRP.Position - hrp.Position).Magnitude
				if dist < shortest then
					shortest = dist
					nearest = bossHRP
				end
			end
		end
	end
	
	return nearest
end

-- =========================
-- Main Aimlock & Highlight Loop
-- =========================
local renderConnMain = RunService.RenderStepped:Connect(function()
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= player and isEnemy(p) and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
            local humanoid = p.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                if not highlights[p] then
                    local highlight = Instance.new("Highlight")
                    highlight.Adornee = p.Character
                    highlight.FillColor = Color3.fromRGB(240, 248, 255)
                    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
                    highlight.Parent = p.Character
                    highlights[p] = highlight
                end
            else
                if highlights[p] then
                    highlights[p]:Destroy()
                    highlights[p] = nil
                end
            end
        else
            if highlights[p] then
                highlights[p]:Destroy()
                highlights[p] = nil
            end
        end
    end

    local bossFolder = Workspace:FindFirstChild("Enemies")
    if bossFolder then
        for _, boss in pairs(bossFolder:GetChildren()) do
            local humanoid = boss:FindFirstChildOfClass("Humanoid")
            if boss:FindFirstChild("HumanoidRootPart") and humanoid and humanoid.Health > 0 then
                if not bossHighlights[boss] then
                    local highlight = Instance.new("Highlight")
                    highlight.Adornee = boss
                    highlight.FillColor = Color3.fromRGB(0, 0, 255)
                    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
                    highlight.Parent = boss
                    bossHighlights[boss] = highlight
                end
            else
                if bossHighlights[boss] then
                    bossHighlights[boss]:Destroy()
                    bossHighlights[boss] = nil
                end
            end
        end
    end

    applySettings()

    if not tiltEnabled then
        if aimlockEnabled then
            local target = getNearestEnemy(500)  
            if target then  
                camera.CFrame = CFrame.new(camera.CFrame.Position, target.Position)  
            end
        end
        
        if bossAimlockEnabled then  
            local targetBoss = getNearestBoss(500)  
            if targetBoss then  
                camera.CFrame = CFrame.new(camera.CFrame.Position, targetBoss.Position)  
             end
         end
    end
end)
table.insert(connections, renderConnMain)

-- =========================
-- Tilt Camera Function
-- =========================
local function disconnectTiltConn()
	if tiltConn then
		tiltConn:Disconnect()
		tiltConn = nil
	end
end

local function stopTiltSmooth()
	disconnectTiltConn()
	if not preTiltCFrame then return end

	local startCF = camera.CFrame
	local endCF = preTiltCFrame
	preTiltCFrame = nil

	local a = 0
	local restoreConn
	restoreConn = RunService.RenderStepped:Connect(function(dt)
		a = math.min(a + dt * 5, 1)
		camera.CFrame = startCF:Lerp(endCF, a)
		if a >= 1 then
			restoreConn:Disconnect()
		end
	end)
end

local function startTilt()
	disconnectTiltConn()

	preTiltCFrame = preTiltCFrame or camera.CFrame
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end
	local humanoid = char:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end

	local startCF = camera.CFrame
	local camPos = startCF.Position

	local tiltOffset
	if humanoid.FloorMaterial ~= Enum.Material.Air then
		tiltOffset = Vector3.new(0, 10, 0)
	else
		tiltOffset = Vector3.new(0, 30, 0)
	end

	local downLook = hrp.Position - tiltOffset
	local targetCF = CFrame.new(camPos, downLook)

	local alpha = 0
	tiltConn = RunService.RenderStepped:Connect(function(dt)
		if not (tiltEnabled and next(rightTouches) and hrp.Parent) then
			stopTiltSmooth()
			return
		end

		if alpha < 1 then
			alpha = math.min(alpha + dt * 2, 1)
			camera.CFrame = startCF:Lerp(targetCF, alpha)
		else
			camera.CFrame = targetCF
		end
	end)
end

-- =========================
-- Touch tracking
-- =========================
UserInputService.TouchStarted:Connect(function(touch)
	if touch.Position.X > camera.ViewportSize.X / 2 then
		rightTouches[touch] = true
		if tiltEnabled then
			startTilt()
		end
	end
end)

UserInputService.TouchEnded:Connect(function(touch)
	if rightTouches[touch] then
		rightTouches[touch] = nil
		if not next(rightTouches) then
			stopTiltSmooth()
			tiltEnabled = false
			vActive = false
			zActive = false
		end
	end
end)

-- =========================
-- Target tracking Health with Raycast
-- =========================
local function setTarget(npc)
	if npc ~= currentTarget then
		if healthConn then
			healthConn:Disconnect()
			healthConn = nil
		end
		currentTarget = nil

		if npc then
			currentTarget = npc
			local humanoid = npc:FindFirstChildOfClass("Humanoid")
			if humanoid then
				local lastHealth = humanoid.Health
				healthConn = humanoid.HealthChanged:Connect(function(newHealth)
					if currentTool then
						local toolName = currentTool.Name
						if (toolName == "Dough-Dough" and vActive) or (toolName == "Shark Anchor" and zActive) then
							if newHealth < lastHealth then
								tiltEnabled = true
								if next(rightTouches) then
									startTilt()
								end
							end
						end
					end
					lastHealth = newHealth
				end)
			end
		end
	end
end

local renderConnRaycast = RunService.RenderStepped:Connect(function()
	local whitelist = {}

	if aimlockEnabled then
		for _, p in pairs(Players:GetPlayers()) do
			if p ~= player and isEnemy(p) and p.Character then
				table.insert(whitelist, p.Character)
			end
		end
	end

	if bossAimlockEnabled then
		local bossFolder = Workspace:FindFirstChild("Enemies")
		if bossFolder then
			for _, boss in pairs(bossFolder:GetChildren()) do
				table.insert(whitelist, boss)
			end
		end
	end

	local rayParams = RaycastParams.new()
	rayParams.FilterDescendantsInstances = whitelist
	rayParams.FilterType = Enum.RaycastFilterType.Whitelist

	local rayOrigin = camera.CFrame.Position  
	local rayDirection = camera.CFrame.LookVector * 1000  
	local result = Workspace:Raycast(rayOrigin, rayDirection, rayParams)  

	if result and result.Instance then  
		local npc = result.Instance:FindFirstAncestorWhichIsA("Model")  
		if npc and npc:FindFirstChildOfClass("Humanoid") then  
			if aimlockEnabled then
				local targetPlayer = Players:GetPlayerFromCharacter(npc)
				if targetPlayer and isEnemy(targetPlayer) then
					setTarget(npc)
					return
				end
			end

			if bossAimlockEnabled then
				local bossFolder = Workspace:FindFirstChild("Enemies")
				if bossFolder and npc:IsDescendantOf(bossFolder) then
					setTarget(npc)
					return
				end
			end
		end
	end
	setTarget(nil)
end)
table.insert(connections, renderConnRaycast)

-- =========================
-- Tool equip / unequip 
-- =========================
local function hookTool(tool)
	currentTool = tool
	tool.AncestryChanged:Connect(function(_, parent)
		if not parent then
			currentTool = nil
			vActive = false
			zActive = false
			tiltEnabled = false
			stopTiltSmooth()
		end
	end)
end

char.ChildAdded:Connect(function(child)
	if child:IsA("Tool") then
		hookTool(child)
	end
end)

char.ChildRemoved:Connect(function(child)
	if child == currentTool then
		currentTool = nil
		vActive = false
		zActive = false
		tiltEnabled = false
		stopTiltSmooth()
	end
end)

-- =========================
-- V Skill Detection
-- =========================
local old
old = hookmetamethod(game, "__namecall", function(self, ...)
	local method = getnamecallmethod()
	local args = {...}

	if (method == "InvokeServer" or method == "FireServer") then
		local a1 = args[1]

		if typeof(a1) == "string" and a1:upper() == "V" then
			if currentTool and currentTool.Name == "Dough-Dough" then
				vActive = true
				local stamp = os.clock()
				task.delay(2, function()
					if not tiltEnabled and os.clock() - stamp >= 2 then
						vActive = false
					end
				end)
			end
		end

		if typeof(a1) == "string" and a1:upper() == "Z" then
			if currentTool and currentTool.Name == "Shark Anchor" then
				zActive = true
				local stamp = os.clock()
				task.delay(2, function()
					if not tiltEnabled and os.clock() - stamp >= 2 then
						zActive = false
					end
				end)
			end
		end

		if currentTool and currentTool.Name == "Shark Anchor" and self.Name == "EquipEvent" then
			local arg1 = args[1]
			if arg1 == false then
				currentTool = nil
				zActive = false
				tiltEnabled = false
				stopTiltSmooth()
			end
		end
	end
	return old(self, ...)
end)

-- =========================
-- Cleanup 
-- =========================
local oldHook = old
local function cleanup()
    for _, conn in pairs(connections) do
        if conn.Connected then conn:Disconnect() end
    end
    connections = {}

    if healthConn then
        healthConn:Disconnect()
        healthConn = nil
    end

    disconnectTiltConn()
    currentTool = nil
    rightTouches = {}
    vActive = false
    zActive = false
    tiltEnabled = false
    preTiltCFrame = nil

    if oldHook then
        hookmetamethod(game, "__namecall", oldHook)
        oldHook = nil
    end

    for _, h in pairs(highlights) do
        h:Destroy()
    end
    highlights = {}
    for _, h in pairs(bossHighlights) do
        h:Destroy()
    end
    bossHighlights = {}
end

-- =========================
-- lifecycle
-- =========================
player.CharacterAdded:Connect(function(c)
	cleanup()
	char = c
	humanoid = char:WaitForChild("Humanoid")
	vActive = false
	zActive = false
	tiltEnabled = false
	rightTouches = {}
	stopTiltSmooth()
end)

player.CharacterRemoving:Connect(function()
	vActive = false
	zActive = false
	tiltEnabled = false
	rightTouches = {}
	disconnectTiltConn()
	currentTool = nil
end)

	-- =========================

	-- RETURN TABLE FOR MAIN SCRIPT USAGE
	return {
		toggleAimlock = function(state)
			aimlockEnabled = state
		end,
		toggleBossAimlock = function(state)
			bossAimlockEnabled = state
		end,
		cleanup = cleanup
	}
end

return AimlockModule
